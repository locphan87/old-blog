{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/functional-programming-in-java-script","result":{"data":{"post":{"__typename":"MdxPost","slug":"/functional-programming-in-java-script","title":"Functional Programming in JavaScript","date":"05.09.2019","tags":[{"name":"javascript","slug":"javascript"},{"name":"functional-programming","slug":"functional-programming"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Functional Programming in JavaScript\",\n  \"date\": \"2019-09-05\",\n  \"tags\": [\"javascript\", \"functional-programming\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Hello FP!\"), mdx(\"p\", null, \"Functional programming is a software paradigm that will radically change the way in which you approach any programming endeavor. This is evident in this simple example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"document.getElementById('message').innerHTML = '<h1>Hello FP!</h1>';\\n\")), mdx(\"p\", null, \"While this program is very trivial, without any effort, it can quickly become problematic. What if you wanted to change the formatting from an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<h1>\"), \" to an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<h2>\"), \"? Or change the target element? Inevitably, you would have to rewrite this statement again.\"), mdx(\"p\", null, \"Consider wrapping it all inside a function and making these data points function parameters. Let\\u2019s explore this further, but instead of using one big function, we\\u2019ll create smaller functions and combine them all with a function called compose:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"compose(addToDom, h1, echo('Hello FP!'));\\n\")), mdx(\"p\", null, \"Combining simple functions to create more meaningful programs is the central theme of functional programming. It also creates very extensible code as I can easily swap any function (like h1 for an h2) without running the risk of breaking other parts of the program. What is compose? There\\u2019s a lot more to cover to understand this, so let\\u2019s dive in!\"), mdx(\"p\", null, \"If you\\u2019re feeling adventurous, you can play with this program here: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/guwiji/edit?html,js,output\"\n  }), \"http://jsbin.com/guwiji/edit?html,js,output\"), \".\"), mdx(\"h2\", null, \"Why JavaScript?\"), mdx(\"p\", null, \"The answer is simple: omnipresence. JavaScript is a dynamically typed, object-oriented, functional, general purpose language that contains an immensely expressive syntax. It\\u2019s one of the most ubiquitous languages ever created and can be seen in the development of mobile applications, websites, web servers, desktop and embedded applications, and even databases.\"), mdx(\"p\", null, \"From its ancestors Lisp and Scheme, JavaScript inherits higher order functions, closures, array literals, and other features that make JavaScript a superb platform for applying functional programming techniques. In fact, functions are the primary \\u201Cunit of work\\u201D in JavaScript.\"), mdx(\"p\", null, \"This article assumes a good understanding of JavaScript, but here are some points to consider:\"), mdx(\"h3\", null, \"Lambda Expressions\"), mdx(\"p\", null, \"Known as fat arrow functions in the JavaScript world, lambda expressions encode simple one-line anonymous functions with shorter notation compared to traditional function declaration. You could have lambda functions of multiple lines, but one-liners are the more common use case. Here\\u2019s a simple example of a function used to add 2 numbers:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const add = (a, b) => a + b;\\nadd(2, 3); //-> 5\\n\")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./f1.png\",\n    \"alt\": null\n  })), mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }))), mdx(\"h3\", null, \"Higher order Functions\"), mdx(\"p\", null, \"In JavaScript, functions are first-class objects, which means they can be used in a first-class manner just like any other object. Hence, you can intuitively expect that functions\\ncan be assigned to variables, passed in as parameters, and returned from other functions. This versatility is what gives JavaScript functions the title of higher order functions.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// assign function to variable\\nconst multiplier = (a, b) => a * b;\\n// pass function as argument\\nconst applyOperation = (a, b, opt) => opt(a, b);\\napplyOperation (2, 3, multiplier); //-> 6\\n// return functions from other functions\\nfunction add(a) {\\n  return function (b) {\\n    return a + b;\\n  }\\n}\\nadd(3)(3); //-> 6\\n\")), mdx(\"p\", null, \"You can try out higher order functions here: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/\"\n  }), \"http://jsbin.com/\"), \" kiruba/edit?js,console.\"), mdx(\"h3\", null, \"Closures\"), mdx(\"p\", null, \"A closure is a data structure that binds a function to its environment at the moment it\\u2019s declared. It is based on the textual location of the function declaration; therefore, a closure is also called a static or lexical scope surrounding the function definition. Because closures give functions access to its surrounding state, you can solve many problems in a terse and concise way.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"For a thorough exploration of JavaScript, try reading\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.manning.com/books/secrets-of-the-javascript-ninja-second-edition\"\n  }), \"Secrets of a JavaScript Ninja 2nd Edition\"), \" (Manning 2016).\"), mdx(\"h3\", null, \"Does functional programming replace object-oriented?\"), mdx(\"p\", null, \"It\\u2019s important to know that JavaScript is as functional as it is object-oriented\\u2014and both of these are useful for implementing mid-to-large size applications. The good news is that functional programming and object-oriented programming are not mutually exclusive and can be used simultaneously. In fact, platforms like Scala and F# have blended both paradigms successfully into a single language, making them very pragmatic and geared towards productivity. JavaScript is another hybrid language that provides the freedom to use these orthogonal paradigms in the same code base.\"), mdx(\"h2\", null, \"Functional Programming\"), mdx(\"p\", null, \"Functional programming is a software development style that emphasizes the use functions. Its main purpose is to abstract control flow and operations on data with functions in order to avoid side effects and reduce mutation of state in your code.\"), mdx(\"p\", null, \"There is a small set of very important concepts\\u2014borrowed from mathematics\\u2014that form the backbone of all functional programming.\"), mdx(\"h3\", null, \"Pure Functions\"), mdx(\"p\", null, \"In order to understand functional programming, you must first understand functions in the mathematical sense as being a mapping of types. The set of a function\\u2019s input values is called the domain and the set of possible values returned is the range. Visually:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./f2.png\",\n    \"alt\": null\n  })), mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }))), mdx(\"p\", null, \"Simply, the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isEmpty\"), \" used to validate whether a string has length zero is a mapping from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Boolean\"), \". This is written as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"isEmpty :: String -> Boolean\\n\")), mdx(\"p\", null, \"Functional programming is based on the premise that you will build immutable programs solely based on pure functions. A pure function has the following qualities:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It depends only on the input provided and not on any hidden or external state that may change as a function\\u2019s evaluation proceeds or between function calls.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It does not inflict changes beyond its scope (like modifying a global object or a parameter reference).\\nBoth points refer to the presence of side effects in your code; behavior that is to be avoided at all costs:\")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./f3.png\",\n    \"alt\": null\n  })), mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }))), mdx(\"p\", null, \"The concept of pure functions leads into another concept in functional programming: referential transparency.\"), mdx(\"h3\", null, \"Referential Transparency\"), mdx(\"p\", null, \"Referential transparency (RT) is a more formal way of defining a pure function. Purity in this sense refers to the existence of a pure mapping between a function\\u2019s arguments and its return value. Hence, if a function consistently yields the same result on the same input, it is said to be referentially transparent. The multiplier and adder functions shown earlier were RT. Here\\u2019s an example of a non-RT program:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const nums = [80, null, 90, 100];\\nconst total = 0;\\nconst validNums = 0;\\nfunction average() {\\n  // Depends on the external variable nums, total, validNums\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== null || nums[i] !== undefined) {\\n      total += nums[i];\\n      validNums++;\\n    }\\n  }\\n  const newAverage = total / validNums;\\n  return Math.round(newAverage);\\n}\\n\")), mdx(\"p\", null, \"The problems with this program are due to its exposure to side effects by relying on external variables: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"total\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validNums\"), \". If any of these variables change in between calls to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"average\"), \", it yields different results.\"), mdx(\"p\", null, \"RT exercise: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/lipewu/edit?js,console\"\n  }), \"http://jsbin.com/lipewu/edit?js,console\"), \".\"), mdx(\"h2\", null, \"Functional Techniques\"), mdx(\"p\", null, \"Functional programming contains a set of very compelling techniques that drive your application\\u2019s control and data flow. Pure functional programs have many of these techniques built into them, such as automatic currying (which we\\u2019ll see in a bit). Unfortunately, JavaScript doesn\\u2019t. Now, this doesn\\u2019t mean you can\\u2019t use JS functionally. In fact, because JavaScript has support for closures and higher order functions, you can very easily extend the platform via functional libraries to support all of the most important functional techniques you\\u2019ll need.\"), mdx(\"h3\", null, \"Away with loops!\"), mdx(\"p\", null, \"A noticeable quality of functional programs is the absence of the standard looping mechanisms: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"for\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"while\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"do-while\"), \". The reason here is that pure functional programs don\\u2019t mutate variables (like a loop counter) after they've been initialized. Instead, we will take advantage of higher order functions\\u2014like: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"forEach\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \" to abstract iteration schemes, which also help us remove a few if-else conditionals while we\\u2019re at it. JavaScript has native implementations of these functions, but it\\u2019s worth considering the implementations provided in the library \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Lodash.js\"), \", as they are more extensible.\"), mdx(\"p\", null, \"You can download Lodash.js here: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://lodash.com\"\n  }), \"https://lodash.com\"), \".\"), mdx(\"p\", null, \"Lodash.js defines a global object wrapper \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \" (an underscore), which can be used to unlock all of its functionality, starting with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.forEach\"), \":\"), mdx(\"h4\", null, mdx(\"span\", {\n    className: \"normal-case\"\n  }, \"_.forEach\")), mdx(\"p\", null, \"This function iterates over the elements of a collection, invoking the provided iteratee function on each one. The callback function is supplied 3 arguments: value, index, and array.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"_.foreach([80, 90, 100], function(value) {\\n  setTimeout(function() {\\n    console.log(value);\\n  }, 100);\\n}).value();\\n\")), mdx(\"p\", null, \"Aside from not having to keep track of loop counters and array length, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.forEach\"), \" also makes your code more declarative and easier to understand. Also, because the body of the loop is encapsulated inside a function, it properly binds each loop value into the callback\\u2019s parameter, avoiding some of those nasty scoping JavaScript bugs.\"), mdx(\"h4\", null, mdx(\"span\", {\n    className: \"normal-case\"\n  }, \"_.map\")), mdx(\"p\", null, \"Mapping functions onto containers is an important part of functional programming. For arrays, I can use a mapping function to transform its contents into an array of similar length as the original, while keeping the original intact. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.map\"), \" function also has the built-in feature of skipping nulls, so it saves us from having to manually do if-else null checks.\"), mdx(\"p\", null, \"The function supplied to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.map\"), \" is invoked with the same arguments as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.forEach\"), \". Given a function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const toLetter = function (grade) {\\n  if(grade >= 90) return 'A';\\n  if(grade >= 80) return 'B';\\n  if(grade >= 70) return 'C';\\n  if(grade >= 60) return 'D';\\n  return 'F';\\n};\\n\")), mdx(\"p\", null, \"We can transform a list of numerical grades into letter grades:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"_.map([20, 98, 100, 73, 85, 50], toLetter);\\n//-> [F, A, A, C, B, F]\\n\")), mdx(\"h4\", null, mdx(\"span\", {\n    className: \"normal-case\"\n  }, \"_.filter\")), mdx(\"p\", null, \"Filter transforms an array by mapping a predicate function (function with a boolean return value) onto each element. The resulting array is made up of, potentially, a subset of elements for which the predicate returns true.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"_.filter(['Spain', 'USA', 'Serbia', 'Uganda'], (name) => name.substring(0,1) === 'S');\\n//-> [Spain, Serbia]\\n\")), mdx(\"p\", null, \"The function supplied to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.filter\"), \" has the same arguments as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.map\"), \". As you can see from the code above, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.filter\"), \" abstracts the task of performing an if-else check to remove elements from the array, where the condition clause is encoded as the predicate function.\"), mdx(\"h4\", null, mdx(\"span\", {\n    className: \"normal-case\"\n  }, \"_.reduce\")), mdx(\"p\", null, \"Typically used as a terminal operation originating from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.map\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.reduce\"), \" can be used to fold or gather the contents of an array by compressing it into a single value. Each successive invocation is supplied the return value of the previous. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.reduce\"), \" is typically seen as combined with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.map\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.filter\"), \":\"), mdx(\"p\", null, \"The accumulator function is supplied the current running total (or accumulated value), the current value, index, and the array.\"), mdx(\"p\", null, \"Map, reduce, filter exercise: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/cihuyo/edit?js,console\"\n  }), \"http://jsbin.com/cihuyo/edit?js,console\"), \".\"), mdx(\"h4\", null, \"Function Chaining\"), mdx(\"p\", null, \"Functions like map, filter, and reduce are just a few of an entire library of functions in Lodash. In fact, all functions in Lodash are designed to be chainable, starting with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.chain()\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const users = [\\n  { 'user': 'Haskell', 'birth': 1900 },\\n  { 'user': 'Turing', 'birth': 1903 },\\n  { 'user': 'Rosser', 'birth': 1907 }\\n];\\nconst youngest = _.chain(users)\\n  .sortBy('birth').last()\\n  .value(); //-> Rosser\\n\")), mdx(\"p\", null, \"Chaining functions this way leads to very declarative code, which describes what the program should do rather than how it does it. Function chains allow you to describe the parts of your application without actually running it. Only when the last function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.value()\"), \" is invoked does evaluation actually occur.\"), mdx(\"h4\", null, \"Recursion\"), mdx(\"p\", null, \"Recursion has many uses in software, especially when solving self-similar types of problems such as traversing trees or mathematical progressions like Fibonacci. It turns out recursion can also be extremely effective at traversing any type of sequential data structures such as arrays, which is why it\\u2019s become the de facto iteration mechanism in functional languages.\"), mdx(\"p\", null, \"Traversing arrays recursively originates from realizing arrays are self-defined as collections, each having a head and a tail, both available as Lodash operations. Here\\u2019s a quick example of a sum function to add all of the elements in an array.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function sum(arr) {\\n  const list = _(arr);\\n\\n  return list.isEmpty() ? return 0 :\\n    list.head() + sum(list.tail());\\n}\\nsum([]); //-> 0\\nsum([1,2,3,4,5,6,7,8,9]); //->45\\n\")), mdx(\"p\", null, \"The main benefit of recursion is that you can loop in an immutable manner since there\\u2019s no explicit loop counter to update. Hence, the responsibility of moving through the elements in an array is ceded entirely to the language runtime.\"), mdx(\"h3\", null, \"Function Abstractions\"), mdx(\"p\", null, \"Functional programming provides very powerful abstractions that allow you to create functions from the definition of other functions or to augment the evaluation of existing functions. The first abstraction we\\u2019ll talk about is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.curry\"), \".\"), mdx(\"h4\", null, \"Currying\"), mdx(\"p\", null, \"Currying is a technique that converts a multivariable function into a step-wise sequence of unary functions. In other words, a function with parameters: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f(a, b, c)\"), \" is internally augmented to one that works on parameters one at a time: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f(a) -> f(b) -> f(c)\"), \". Consider the case of a function name that returns first and last name:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// name :: String -> String -> String\\nconst name = function (first) {\\n  return function (last) {\\n    return `${last}, ${first}`\\n  }\\n}\\n\")), mdx(\"p\", null, \"Instead of writing it like this, we can use Lodash\\u2019s automatic currying functionality:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const name = _.curry(function(last, first) {\\n  return [last, first].join(',');\\n});\\n\\n// When supplied both arguments, it evaluates the function immediately\\nname('Curry')('Haskell'); //-> 'Curry, Haskell'\\n\\n// When supplied one argument, it returns another function\\nname('Curry'); //-> Function\\n\")), mdx(\"p\", null, \"As you can see from the example above, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" is a function of two arguments. From this curried version, a family of functions is born by partially applying only the first argument:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const curry = name('Curry');\\ncurry('Haskell'); //-> 'Curry, Haskell'\\ncurry('Samuel'); //-> 'Curry, Samuel'\\ncurry('Anna'); //-> 'Curry, Anna'\\n\")), mdx(\"p\", null, \"Currying exercise: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/dubaqa/edit?html,js,console\"\n  }), \"http://jsbin.com/dubaqa/edit?html,js,console\"), \".\"), mdx(\"p\", null, \"This idea of partially applying arguments has another modality, known as partial application.\"), mdx(\"h4\", null, \"Partial Application\"), mdx(\"p\", null, \"Partial application is an operation that binds a subset of a non-variadic function\\u2019s parameters to fixed values, creating a function of smaller arity. This is especially useful when implementing presets or default function arguments. Consider the following log function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function log (level, target, message)\\n\")), mdx(\"p\", null, \"I can use this function to log a message with different levels and target either the console or an alert box. Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.partial\"), \", I can create an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"infoConsoleLogger\"), \", for example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const infoConsoleLogger = _.partial(log, 'console', 'INFO');\\ninfoConsoleLogger('Users name ' + name('Curry', 'Haskell'));\\n\")), mdx(\"p\", null, \"Partial application can also be used with placeholders \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \" to extend language with native behavior. Consider these two examples:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Take the first N characters of a String\\nString.prototype.first = _.partial(String.prototype.substring, 0, _);\\n'Functional Programming'.first(3); //-> 'Fun'\\n// Convert any name into a Last, First format\\nString.prototype.asName = _.partial(String.prototype.replace, /(\\\\w+)\\\\s(\\\\w+)/, '$2, $1');\\n'Alonzo Church'.asName(); //-> 'Church, Alonzo'\\n\")), mdx(\"p\", null, \"Both currying and partial application are extremely useful when combined with composition.\"), mdx(\"h4\", null, \"Composition\"), mdx(\"p\", null, \"Composition is the process used to group together the execution of simpler functions. In essence, composition is a function derived from other functions.\"), mdx(\"p\", null, \"The composition of 2 functions \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"g\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f\"), \" (read \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f\"), \" composed of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"g\"), \") is given by:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"f \\xB7 g = f(g) = compose :: (B -> C) -> (A -> B) -> (A -> C)\\n\")), mdx(\"p\", null, \"You can visualize the composition of two functions as a mapping of sets linking their inputs and outputs:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./f4.png\",\n    \"alt\": null\n  })), mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }))), mdx(\"p\", null, \"In simple terms, this means the output of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"g\"), \" will be passed into the input of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"f\"), \". Let\\u2019s see this in action using Lodash\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.compose\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const str = \\\"We can only see a short distance ahead but we can see plenty there that needs to be done\\\";\\nconst explode = (str) => str.split(/\\\\s+/);\\nconst count = (arr) => arr.length;\\nconst countWords = _.compose(count, explode); //-> 19\\n\")), mdx(\"p\", null, \"Because functions have single return values, it\\u2019s imperative for the function receiving the input (in this case f) to behave as a unary function. This is where currying is so useful, as it can be used to reduce a function\\u2019s parameters to one. Let\\u2019s expand on the example shown previously; this time we will determine if a block of text contains 10 words:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const check = _.curry((len, size) => size >= len);\\nconst check10 = check(10);\\nconst checkText = _.compose(check10, count, explode);\\ncheckText(str); //-> true\\n\")), mdx(\"p\", null, \"Currying and composition exercise: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/fokixa/edit?html,js,console\"\n  }), \"http://jsbin.com/fokixa/edit?html,js,console\"), \".\"), mdx(\"h2\", null, \"Functional Data Types\"), mdx(\"p\", null, \"Currying and composition provide abstractions over functions - the drivers for behavior in your application. Functional data types like functors and monads provide abstractions over the data. Functional data types part from the notion of mapping functions onto containers. You saw this earlier with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_.map\"), \" function on arrays. In a similar manner, we can map functions over any type.\"), mdx(\"h3\", null, \"Containerizing\"), mdx(\"p\", null, \"The idea behind containerizing is very simple but has far reaching applications. The goal is to place values in a container. By doing this, we hope to create a logical barrier that promotes transforming values immutably and side-effect free. Let\\u2019s define our simple container type, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wrapper\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Wrapper = function(val) {\\n  this.val = val;\\n};\\nWrapper.prototype.map = (f) => f(this.val);\\nconst wrap = (val) => new Wrapper(val);\\n\")), mdx(\"p\", null, \"Once we wrap a value, the rule is that you can only map functions onto it to transform and retrieve it. Let\\u2019s see an example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const msg = 'Hello FP!';\\nwrap(msg).map(_.words); //-> ['Hello', 'FP!']\\n\")), mdx(\"p\", null, \"This idea is rather simple: you put the value into a container and run a function over it. We can make this more powerful if we could continue mapping functions over the container multiple times, just like map. Consider this variation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wrapper.map\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"Wrapper.prototype.map = function(f) {\\n  return wrap(f(this.val))\\n}\\n\")), mdx(\"p\", null, \"As you can see now, aside from mapping the function over the value, the result is placed back into the container, which allows for a chainable sequence of operations to take place:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const msg = 'Hello FP!';\\nwrap(msg).map(_.words).map(_.size); //-> Wrapper(2)\\n\")), mdx(\"p\", null, \"You should realize that the original wrapped object was never actually touched, and not because it\\u2019s a string, but because mapping functions over the value always returns a new value, leaving the original unaltered.\"), mdx(\"h3\", null, \"Functors\"), mdx(\"p\", null, \"That\\u2019s right, the array map is a functor since you can map a function onto its elements and the result is again an array. In essence, a functor is nothing more than a type that implements a mapping function with the purpose of lifting values into a container. Hence, a functor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"F\"), \" defines a mapping function as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"F.prototype.map = function(f) {\\n  return F.of(f(this.val))\\n}\\n\")), mdx(\"p\", null, \"The function F.of is nothing more than a way to instantiate the data type without having to call new. Diagraming the example code above:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./f5.png\",\n    \"alt\": null\n  })), mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }))), mdx(\"p\", null, \"Functors are important because they introduce the idea of a function \\u201Creaching\\u201D into the container, modifying it, and placing the value \\u201Cback into\\u201D it. As is, however, this wrapper doesn\\u2019t provide much more value. For instance, what happens if I wrap a null object and attempt to map functions over it?\"), mdx(\"p\", null, \"Functor exercise: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/tetet/20/edit?html,js,console\"\n  }), \"http://jsbin.com/tetet/20/edit?html,js,console\"), \".\"), mdx(\"h3\", null, \"Monads\"), mdx(\"p\", null, \"Monads are data types similar to functors, but they also define the rules by which values are contained within them. The monad type, as such, is an abstract data type with the following interface:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"INTERFACE\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"DESCRIPTION\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Type constructor\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Used for creating monadic types\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Unit function\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Used for inserting a value into a monadic structure. Typically called \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"of\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"fromNullable\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Bind function\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Used for chaining operations on monadic values, called \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"map\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Join operation\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Used to flatten layers of monadic structures into one. Important when used in the composition of functions that return monadic types\")))), mdx(\"p\", null, \"Monadic types are concrete implementations of this interface. In practical programming problems, monadic types are frequently seen to abstract and consolidate null checks and error handling. The two most frequently used are the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Maybe\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either\"), \" types.\"), mdx(\"h4\", null, \"Maybe\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Maybe\"), \" monad can be used to model the presence or absence of a value (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \") in a centralized and secure manner.\"), mdx(\"p\", null, \"Implementation details can be found at: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/folktale/data.maybe\"\n  }), \"https://github.com/folktale/data.maybe\"), \".\"), mdx(\"p\", null, \"This data type is an abstract type with 2 concrete implementations:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"TYPE\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"DESCRIPTION\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Just(val)\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Always contains a valid value\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Nothing()\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Represents a container that has no value, or the case of a failure with no additional information\")))), mdx(\"p\", null, \"Let\\u2019s see this in action:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const user = {name: 'Haskell Curry', age: 14};\\nMaybe.fromNullable(user)\\n  .map(_.property('age'))\\n  .map(add(1)); //-> Maybe(15)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Maybe\"), \" receives an object, and sets out to perform a couple of transformations: extracting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"age\"), \" property and then adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" to it. But what would happen in the case of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \"?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"Maybe.fromNullable(null)\\n  .map(_.property('age'))\\n  .map(add(1)); //-> Nothing()\\n\")), mdx(\"p\", null, \"This is the remarkable thing: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Nothing\"), \" happens. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Maybe\"), \" has provided specific logic in its unit function that abstracts null checks from your code. This monad can also be used to abstract out nested if-else statements present in imperative code. Consider this example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function getCountry(student) {\\n  const school = student.getSchool();\\n  if (school !== null) {\\n    const addr = school.getAddress();\\n    if (addr !== null) {\\n      return addr.getCountry();\\n    }\\n  }\\n  return 'Country does not exist!';\\n}\\n\")), mdx(\"p\", null, \"Watch how this code becomes much more streamlined using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Maybe\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const getCountry = (student) => {\\n  return Maybe.fromNullable(student)\\n    .map(_.property('school'))\\n    .map(_.property('address'))\\n    .map(_.property('country'))\\n    .getOrElse('Country does not exist!');\\n}\\n\")), mdx(\"h4\", null, \"Either\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either\"), \" represents a logical disjunction (OR) between two values \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \", but never at the same time. Unlike \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Maybe\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either\"), \" can be used to signal a failure in your code and provide a possible recovery route. It also has two concrete implementations:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"TYPE\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"DESCRIPTION\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Left(a)\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Can contain a possible error message or an exception to throw\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Right(b)\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Always contains the successful value (known as biased on the right)\")))), mdx(\"p\", null, \"Implementation details of Either can be found here: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/folktale/data.either\"\n  }), \"https://github.com/folktale/data.either\"), \".\"), mdx(\"p\", null, \"Consider this example to look up strings by some key:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const messages = {\\n  'welcome': 'Hello FP!'\\n};\\nconst lookUp = function (obj, key) {\\n  const str = obj[key];\\n  if (str) {\\n    return Either.fromNullable(str);\\n  }\\n  return Either.Left('String not found!');\\n};\\n\")), mdx(\"p\", null, \"Here\\u2019s the work of the monad in the event of valid and invalid cases:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// valid\\nlookUp(messages, 'welcome').map(_.words); // Right(['Hello', 'FP!'])\\n// invalid\\nlookUp(messages, 'badKey').map(_.words); // Left('String not found!');\\n\")), mdx(\"p\", null, \"With both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Maybe\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either\"), \", even if the function fails to look up a value, I can still map functions onto them, safely propagating and securing the error until reaching the end of the expression.\"), mdx(\"p\", null, \"Now try it for yourself: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/juluka/edit?html,js,console\"\n  }), \"http://jsbin.com/juluka/edit?html,js,console\"), \".\"), mdx(\"h2\", null, \"Interacting With the DOM\"), mdx(\"p\", null, \"Since functional programming must be pure and side-effect free, how do you interact with the DOM? Reading from or writing to the DOM are severe causes of side effects in your code since your functions are accessing and modifying a globally shared resource. While we can\\u2019t avoid side effects from occurring, we can at least write code that behaves in a referentially transparent way in the face of HTML reads and writes. Let\\u2019s begin there. I will define two simple operations: read and write:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const read = function (id) {\\n  return function () {\\n    return document.getElementById(id).innerHTML;\\n  };\\n};\\nconst write = function(id) {\\n  return function(value) {\\n    document.getElementById(id).innerHTML = value;\\n  };\\n};\\n\")), mdx(\"p\", null, \"The purpose of creating these curried functions is two-fold:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To isolate the IO operations into singular functions as much as possible.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To control their side effects when used with the IO monad.\")), mdx(\"h3\", null, \"IO Monad\"), mdx(\"p\", null, \"As the name suggests, we have a monad that allows us to do pseudo-side-effect free IO. This monad is mainly in charge of separating the IO operations from the main logic of your code. Let\\u2019s look at a quick example, given the following HTML div:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"<div id='message'>Hello FP!</div>\\nconst performUnsafeIO = IO.from(read('message'))\\n  .map(_.snakeCase)\\n  .map(write('message'));\\n\")), mdx(\"p\", null, \"As is, this expression doesn't effect any change. This is because the IO monad is nothing more than a referentially transparent program description. All of the side effects are executed in one shot with a call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IO.run\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"performUnsafeIO.run();\\n// HTML output\\n<div id='message'>hello_fp</div>\\n\")), mdx(\"p\", null, \"Try out the IO monad: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://jsbin.com/butame/edit?html,js,output\"\n  }), \"http://jsbin.com/butame/edit?html,js,output\"), \".\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"To sum up, functional programming is a paradigm with a radically different philosophy from traditional object-oriented development. The main distinctions are apparent when considering functional programming\\u2019s declarative mode of expressing code, as well as its focus on preserving immutability through functions that execute in a side-effect free environment.\"), mdx(\"p\", null, \"At the core of functional programming lies functional composition and monads. Composition provides function abstractions used to create complex functions from simple ones. While composition abstracts control flow, monads abstract data. Monadic types provide a secure layer where invalid data is guarded from causing your code to fail.\"), mdx(\"p\", null, \"The biggest challenge of large JavaScript application development is dealing with the complexity inherent in the level of flexibility and dynamicity that the language provides. The principles behind functional programming can be used to remedy this and prevent your code from being impacted by other scripts loaded onto the same page, leading to code that is much easier to read, test, and reason about.\"), mdx(\"p\", null, \"With the aim of being terse and expressive, functional programming is a paradigm that can boost your development productivity and create more robust applications.\"), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SOURCES\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"LUIS ATENCIO. Functional Programming in JavaScript on \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://dzone.com/refcardz/functional-programming-with-javascript\"\n  }), \"DZone\"))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"RECOMMENDED BOOK\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.manning.com/books/functional-programming-in-javascript?a_bid=09ffe2cc&a_aid=latenciofpjs\"\n  }), \"Functional Programming in JavaScript\"), \" teaches JavaScript developers functional techniques that will improve extensibility, modularity, reusability, testability, and performance. Through concrete examples and jargon-free explanations, this book teaches you how to apply functional programming to real-life development tasks. By the end of the book, you'll think about application design in a fresh new way.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Hello FP! Functional programming is a software paradigm that will radically change the way in which you approach any programming endeavorâ€¦","timeToRead":12,"banner":null}},"pageContext":{"slug":"/functional-programming-in-java-script","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}